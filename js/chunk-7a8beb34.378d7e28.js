(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-7a8beb34"],{1884:function(n,t,e){"use strict";e.r(t);var a=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("blog-tab",{attrs:{"tab-titles":n.tabs},scopedSlots:n._u([{key:"default",fn:function(t){var a=t.currentItem;return n._l(n.config,(function(t){return e("v-card-text",{directives:[{name:"show",rawName:"v-show",value:a===n.all||a===t.lang,expression:"currentItem===all||currentItem===article.lang"}],key:t.title},[e("article-item",{attrs:{tabs:t.tag,index:t.index,title:t.title,content:t.content}})],1)}))}}])})},o=[],l=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"d-flex justify-center"},[e("v-lazy",[e("v-hover",{scopedSlots:n._u([{key:"default",fn:function(t){var a=t.hover;return[e("v-card",{staticClass:"ma-6 pa-4 article-card",attrs:{"max-width":"1000",elevation:a?13:2,href:"#"+n.$route.path+"/article/"+n.index}},[e("v-card-title",{staticClass:"ml-2 article-title"},[e("div",[n._v(n._s(n.title))])]),e("v-card-text",{staticClass:"ml-2",staticStyle:{"font-size":"9px",color:"#948c9c"}},[n._v(n._s(n.currentTime))]),e("v-card-title",n._l(n.tabs,(function(t,a){return e("v-chip",{key:t,staticClass:"ml-2",attrs:{color:n.colorList[a%6]}},[n._v(n._s(t)+" ")])})),1),e("v-card-text",{staticClass:"ml-2"},[n._v(n._s(n.omit))])],1)]}}])})],1)],1)},i=[],r={name:"ArticleList",props:{title:{type:String,default:"未接收到标题"},content:{type:String,default:"未接收到文章的内容"},tabs:{type:Array},index:{type:Number}},data:()=>({colorList:["default","primary","secondary","orange","red","green"]}),computed:{currentTime(){let n=(new Date).toDateString();return n},omit(){let n=this.content.substr(0,150)+"...";return n}},methods:{}},s=r,m=(e("3ab9"),e("2877")),c=e("6544"),p=e.n(c),h=e("b0af"),d=e("99d9"),y=e("cc20"),x=e("16b7"),k=e("f2e7"),g=e("58df"),b=e("d9bd"),u=Object(g["a"])(x["a"],k["a"]).extend({name:"v-hover",props:{disabled:{type:Boolean,default:!1},value:{type:Boolean,default:void 0}},methods:{onMouseEnter(){this.runDelay("open")},onMouseLeave(){this.runDelay("close")}},render(){if(!this.$scopedSlots.default&&void 0===this.value)return Object(b["c"])("v-hover is missing a default scopedSlot or bound value",this),null;let n;return this.$scopedSlots.default&&(n=this.$scopedSlots.default({hover:this.isActive})),Array.isArray(n)&&1===n.length&&(n=n[0]),n&&!Array.isArray(n)&&n.tag?(this.disabled||(n.data=n.data||{},this._g(n.data,{mouseenter:this.onMouseEnter,mouseleave:this.onMouseLeave})),n):(Object(b["c"])("v-hover should only contain a single element",this),n)}}),f=e("24b2"),_=e("90a2"),w=e("80d2"),v=Object(g["a"])(f["a"],k["a"]).extend({name:"VLazy",directives:{intersect:_["a"]},props:{options:{type:Object,default:()=>({root:void 0,rootMargin:void 0,threshold:void 0})},tag:{type:String,default:"div"},transition:{type:String,default:"fade-transition"}},computed:{styles(){return{...this.measurableStyles}}},methods:{genContent(){const n=this.isActive&&Object(w["r"])(this);return this.transition?this.$createElement("transition",{props:{name:this.transition}},n):n},onObserve(n,t,e){this.isActive||(this.isActive=e)}},render(n){return n(this.tag,{staticClass:"v-lazy",attrs:this.$attrs,directives:[{name:"intersect",value:{handler:this.onObserve,options:this.options}}],on:this.$listeners,style:this.styles},[this.genContent()])}}),M=Object(m["a"])(s,l,i,!1,null,"a232c6f2",null),L=M.exports;p()(M,{VCard:h["a"],VCardText:d["a"],VCardTitle:d["b"],VChip:y["a"],VHover:u,VLazy:v});var z=e("e714"),A=e("c70e"),F={name:"Tags",components:{BlogTab:A["a"],ArticleItem:L},data:()=>({config:z["a"].articleList,tabs:["all","java","go","python","javascript"],all:"all"}),methods:{printInfo(n,t){console.log(t)}}},S=F,j=Object(m["a"])(S,a,o,!1,null,null,null);t["default"]=j.exports;p()(j,{VCardText:d["a"]})},"3ab9":function(n,t,e){"use strict";e("8c6d")},"8c6d":function(n,t,e){},e714:function(n,t,e){"use strict";t["a"]={articleList:[{index:0,title:"猴子选大王问题",tag:["java","base"],lang:"java",display:"n个猴子围成一圈，从编号为k的开始报数1-2-m-1-2-m-……报“m”的猴子就被淘汰，游戏一直进行到圈内只剩一只猴子它就是猴大王了。 想了很长时间不会,问了@Spider-gty，得知用两个一维数组模拟圈可以解决，下面是代码：<div>\n    <hello-world></hello-world>\n</div>",content:'n个猴子围成一圈，从编号为k的开始报数1-2-m-1-2-m-……报“m”的猴子就被淘汰，游戏一直进行到圈内只剩一只猴子它就是猴大王了。\n想了很长时间不会,问了@Spider-gty，得知用两个一维数组模拟圈可以解决，下面是代码：\n```java\nclass MonkeyProblem \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tint k=17;\n\t\tint[] last=new int[k+1];\n\t\tint[] next=new int[k+1];\n\t\tlast[1]=k;next[1]=2;\n\t\tlast[k]=k-1;next[k]=1;\n\t\tfor(int i=2;i<=k-1;i++)\n\t\t{\n\t\t\tlast[i]=i-1;\n\t\t    next[i]=i+1;\n\t\t}\n\t    \n\t\tint result=solve(last,next,1,10);\n\t\tSystem.out.println(result);\n\t\t\n\t}\n    //  Find the correct monkey;\n    //模拟报数过程\n\tstatic int count(int[] l,int[] n,int k,int m)\n\t\t//l是上一个，n是下一个，k是某位置开始，m是往下数多少位\n\t{\n\t\t \n         if(m==1) return  k;\n         k=n[k];\n         return count(l,n,k,m-1);\n\t}\n\t//模拟淘汰过程，opted指被选中报到m的猴子\n\tstatic void eliminate(int[] l,int[] n,int opted)\n\t{\n\t\tn[l[opted]]=n[opted];\n\t\tl[n[opted]]=l[opted];\n\t}\n\tstatic int solve(int[] l,int[] n,int k ,int m)\n\t{\n\t\tif(n[k]==k) return k;\n\t\tint opted=count(l,n,k,m);\n\t\teliminate(l,n,opted);\n\t\tint next=n[opted];\n\t\treturn solve(l,n,next,m);\n\t}\t\n}\n```\n···························································································\n事实上，过多的使用递归会影响程序的性能；按照这个思路，程序可以简化。\nC++版本:\n\n```c++\n#include <iostream>\n\nvoid initialize(int *last, int *next, int length);\n\nint solve(int *, int *, int &, int &);\n\nint main() {\n    std::cout<<"输入猴子的数量:"<<std::endl;\n    int monkey_mount;\n    std::cin>>monkey_mount;\n    int ls[monkey_mount];\n    int nt[monkey_mount];\n    initialize(ls, nt, monkey_mount);\n    int startMonkey = 0;\n    int epoch_length = 8;\n    std::cout << solve(ls, nt, startMonkey, epoch_length) << std::endl;\n\treturn 0;\n}\n\nvoid initialize(int *last, int *next, int length) {\n    for (int i = 1; i < length - 1; ++i) {\n        last[i] = i - 1;\n        next[i] = i + 1;\n    }\n    last[0] = length - 1;\n    next[0] = 1;\n    last[length - 1] = length - 2;\n    next[length - 1] = 0;\n}\n\nint solve(int *last, int *next, int &startMonkey, int &epoch_length) {\n    int monkey = startMonkey;\n    while (next[monkey] != monkey) {\n        for (int i = 1; i < epoch_length; i++)\n            monkey = next[monkey];\n        next[last[monkey]] = next[monkey];\n        last[next[monkey]] = last[monkey];\n        printf("本轮淘汰第%d个猴\\n", monkey);\n        monkey = next[monkey];\n    }\n    return monkey;\n}\n```\n\nnode版本\n\n```js\nconst readline = require(\'readline\').createInterface({\n    input: process.stdin,\n    output: process.stdout\n})\nreadline.question("输入猴子的数量\\n", answer => {\n    let next = [];\n    let last = [];\n    initialize(last, next, answer)\n    console.log(`最终的猴子王是${solve(last, next, 0, answer)}`)\n})\n\n\nfunction initialize(last, next, length) {\n    for (let i = 1; i < length - 1; i++) {\n        last[i] = i - 1;\n        next[i] = i + 1;\n    }\n    last[0] = length - 1;\n    next[0] = 1;\n    last[length - 1] = length - 2;\n    next[length - 1] = 0;\n}\n\nfunction solve(last, next, startMonkey, epoch_length) {\n    let monkey = startMonkey;\n    while (next[monkey] !== monkey) {\n        for (let i = 1; i < epoch_length; i++)\n            monkey = next[monkey];\n        next[last[monkey]] = next[monkey];\n        last[next[monkey]] = last[monkey];\n        console.log(`本轮淘汰第${monkey}个猴子`)\n        monkey = next[monkey];\n    }\n    return monkey;\n}\n```\n\nGo语言版:\n\n```go\npackage main\n\nimport (\n\t"bufio"\n\t"fmt"\n\t"os"\n\t"strconv"\n)\n\nfunc main() {\n\tfmt.Printf("输入猴子的数量:\\n")\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Scan()\n\tmonkeyMount, _ := strconv.Atoi(scanner.Text())\n\tfmt.Printf("输入起始猴子的位置(从0开始):\\n")\n\tscanner.Scan()\n\tstartMonkey, _ := strconv.Atoi(scanner.Text())\n\tfmt.Printf("输入猴子数数的步长:\\n")\n\tscanner.Scan()\n\tepochStep, _ := strconv.Atoi(scanner.Text())\n\tlast := make([]int, monkeyMount, monkeyMount)\n\tnext := make([]int, monkeyMount, monkeyMount)\n\tinitialize(last, next, monkeyMount)\n\tfmt.Printf("最终的猴子王是%d", solve(last, next, startMonkey, epochStep))\n}\n\nfunc initialize(last []int, next []int, length int) {\n\tfor i := 1; i < length-1; i++ {\n\t\tlast[i] = i - 1\n\t\tnext[i] = i + 1\n\t}\n\tlast[0] = length - 1\n\tnext[0] = 1\n\tlast[length-1] = length - 2\n\tnext[length-1] = 0\n}\n\nfunc solve(last []int, next []int, startMonkey int, epochLength int) int {\n\tmonkey := startMonkey\n\tfor monkey != next[monkey] {\n\t\tfor i := 1; i < epochLength; i++ {\n\t\t\tmonkey = next[monkey]\n\t\t}\n\t\tnext[last[monkey]] = next[monkey]\n\t\tlast[next[monkey]] = last[monkey]\n\t\tfmt.Printf("本轮淘汰第%d个猴子\\n", monkey)\n\t\tmonkey = next[monkey]\n\t}\n\treturn monkey\n}\n\n```\n最简单是当然是kotlin\n\n```kotlin\npackage com.wang.binarySearch\n\nimport java.util.*\n\nfun main() {\n    val scanner = Scanner(System.`in`)\n    println("猴子的数量为:")\n    val monkeyMount = scanner.nextInt()\n    println("猴子开始数数位置为:")\n    val startMonkey = scanner.nextInt()\n    println("猴子数数的步长是:")\n    val countStep = scanner.nextInt()\n    val last = Array(monkeyMount) { i: Int -> if (i == 0) monkeyMount - 1 else i - 1 }\n    val next = Array(monkeyMount) { i: Int -> if (i == monkeyMount - 1) 0 else i + 1 }\n    println("猴子王是:${solve(last, next, startMonkey, countStep)}")\n}\n\nfun solve(last: Array<Int>, next: Array<Int>, startMonkey: Int, epochLength: Int): Int {\n    var monkey = startMonkey\n    while (monkey != next[monkey]) {\n        repeat(epochLength - 1) { monkey = next[monkey] }\n        last[next[monkey]] = last[monkey]\n        next[last[monkey]] = next[monkey]\n        println("本轮淘汰第 $monkey 个猴子")\n        monkey = next[monkey]\n    }\n    return monkey\n}\n```\n'},{index:1,title:"Matplotlib绘图",tag:["python","base"],lang:"python",display:"Matplotlib的绘图功能\n@TOC\n\n1.条形图\nimport matplotlib.pyplot as plt\n\ndata = [5, 20, 15, 25, 10]\n\nplt.bar(range(len(data)), data)\nplt.show()\nbar(left, height, width=0.8, bottom=None, **kwargs)",content:"\n\n# Matplotlib的绘图功能\n\n\n</font>\n\n\n@[TOC](文章目录)\n\n## 1.条形图\n\n```python\nimport matplotlib.pyplot as plt\n\ndata = [5, 20, 15, 25, 10]\n\nplt.bar(range(len(data)), data)\nplt.show()\n```\n\n```python\nbar(left, height, width=0.8, bottom=None, **kwargs)\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20201118001059567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ3MjAyNTE4,size_16,color_FFFFFF,t_70#pic_center)\n\n可以通过增加关键字对条形图进行修饰：\n\n1. 颜色\n\n   facecolor(或fc)：用于设置柱体的颜色\n\n   通过 color 关键字参数 可以一次性设置多个颜色，color是一个数组\n\n2. 描边\n\n   - edgecolor 或 ec：描边的颜色，如white,black,blue\n   - linestyle 或 ls:   描边的样式，如 \"-\" , \"--\";\n   - linewidth 或 lw:描边的宽度 ：\n\n3. 填充\n\n   hatch ：hatch的值用于设置填充条形图的图形，如 \"X\", \"o\" ,\"/\" ;\n\n   ==注意：hatch的长个数表示填充的密度，如\"////////\"表示用\"/\"密集得填充==\n\n4. 误差线\n\n   ```python\n   yerr： 定义误差的浮动的绝对值\n   error_kw: 误差线关键字，是一个字典\n   关键字有：\n   ecolor:误差线的颜色\n   elinewidth: 误差线的宽度，即粗细\n   capsize: 误差线帽子的长度\n   ```\n\n   \n\n5. 图例位置\n\n   ```python\n   pyplot.legend(**ky)\n   \n   #loc: 可选'best','upper left','bottom right' 等\n   #bbox_to_anchor=(0.2, 1),以左下角为为原点，调整位置\n   #bbox_transform=ax.transAxes\n   #frameon: 图例是否有边框\n   #下面的操作由于修改边框的颜色\n   leg = plt.legend()\n   leg.get_frame().set_edgecolor('b') \n   \n   ```\n\n6. 合并图例\n\n   ```python\n   #得到坐标轴1图例的句柄和标签值\n   handles_1, labels_1 = ax1.get_legend_handles_labels()\n   #得到坐标轴2图例的句柄和标签值\n   handles_2, labels_2 = ax2.get_legend_handles_labels()\n   #关键字传入,传入label（一个数组）参数可以改变图例的标签值\n   plt.legend(handles=handles_1 + handles_2, bbox_to_anchor=(0.1, 1))\n   ```\n\n7. 设置刻度线标签（tick label）\n\n   ```python\n   import matplotlib.pyplot as plt\n   \n   data = [5, 20, 15, 25, 10]\n   labels = ['Tom', 'Dick', 'Harry', 'Slim', 'Jim']\n   \n   plt.bar(range(len(data)), data, tick_label=labels)\n   plt.show()\n   ```\n\n   ![img](https://img-blog.csdnimg.cn/img_convert/e57e86d46c213253314d581b86f04f87.png)\n\n\n\n示例：\n\n```python\nimport matplotlib.pyplot as plt\n\nlabels = [0.3, 0.5, 1.0, 1.5, 3.0]\nbottom_means = [20, 80, 160, 250, 400]\ntop_means = [210, 250, 1200, 1500, 2600]\ntop_std = [20, 40, 80, 200, 500]\nwidth = 0.15  # the width of the bars: can also be len(x) sequence\n\n#subplots是将多个图画到同一个平面上得工具,在matlab也有同样的函数\n\nfig, ax = plt.subplots()\nax.bar(labels, bottom_means, width, color='white', edgecolor='black', ls='-', lw=1, hatch='////', label='PFOA in water')\nax.bar(labels, top_means, width, color='white', edgecolor='black', ls='-', lw=1, yerr=top_std, bottom=bottom_means,\n       hatch='xx',\n       label='PFOA on SS')\n#设置y轴上得标签值\nax.set_ylabel('PFOA amount (g)')\n#设置图标的标题\nax.set_title('Initial PFOA concentration (mg/L)')\n#设置图例，loc=location，指的是图例的位置\nax.legend(loc='upper left')\n\nplt.show()\n```\n\n### 绘制其他样式的柱形图\n\n* ##### 水平的条形图\n\n  ```python\n  import matplotlib.pyplot as plt\n  \n  data = [5, 20, 15, 25, 10]\n  \n  plt.barh(range(len(data)), data)\n  plt.show()\n  ```\n\n  ![preview](https://img-blog.csdnimg.cn/img_convert/4464a1a847ac9c9b974a0cf05e56ddcf.png)\n\n* **正负条形图**\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\na = np.array([5, 20, 15, 25, 10])\nb = np.array([10, 15, 20, 15, 5])\n\nplt.barh(range(len(a)), a)\nplt.barh(range(len(b)), -b)\nplt.show()\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/9a96e59146eac268d4a28d68641a0c83.png)\n\n## 2.误差线\n\n#### 坐标轴参数\n\n1. 设置双Y坐标轴\n\n   ```python\n   ax2 = plt.twinx()\n   ```\n\n   ==主要通过twinx(\t)方法创建出另一个坐标轴，此时在下面画图将会以右侧纵坐标为准==\n\n2. 修改坐标轴的范围\n\n   ```python\n   pyplot.ylim(ymax=400)\n   pyplot.ylim(ymin=10)\n   pyplot.xlim(xmax=10)\n   ```\n\n3. 设置坐标轴刻度的参数\n\n   ```python\n   pyplot.tick_params(which='major', direction='in', length=6)\n   #可选关键字\n   #可选参数which:选择major or minor\n   #direction:刻度的朝向，可选in or out\n   #length: 刻度的长度\n   #width: 刻度的宽度\n   #size : 刻度标签的大小\n   #axis: 指定是纵坐标还是，横坐标，可选xaxis or yaxis\n   #colors:刻度标签的颜色\n   ```\n\n   ```python\n   axis.xaxis.set_minor_locator(MultipleLocator(0.25))\n   #设置纵坐标或者横坐标的次纵坐标的位置，上面表示每个0.25画一个次纵坐标\n   ```\n\n4. 设置坐标轴颜色\n\n   ```python\n   axis.spines['bottom'].set_color('red')\n   #设置坐标轴的颜色，可选参数top or bottom or left or right\n   ```\n\n5. 隐藏坐标轴\n\n   ```python\n   #隐藏y轴坐标\n   plt.gca().get_yaxis().set_visible(False)\n   #隐藏x轴坐标\n   plt.gca().get_xaxis().set_visible(False)\n   ```\n\n#### plot方法\n\n* **plot([x], y, [fmt], data=None, ****kwargs**)**\n\n  fmt：可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle）\n\n  具体形式  fmt = '\\[color]\\[marker][line]'\n\n  参考了：[matplotlib.pyplot.plot()参数详解](https://blog.csdn.net/sinat_36219858/article/details/79800460)\n\n  ```pyt\n  plot(x, y, 'bo-')  # 蓝色圆点实线\n  ```\n\n  color: 线的颜色\n\n  marker: 点的形状\n\n  line: 线的形状\n\n  ```python\n  \t#maker的可选值\n      =============    ===============================\n      character        description\n      =============    ===============================\n      ``'.'``          point marker\n      ``','``          pixel marker\n      ``'o'``          circle marker\n      ``'v'``          triangle_down marker\n      ``'^'``          triangle_up marker\n      ``'<'``          triangle_left marker\n      ``'>'``          triangle_right marker\n      ``'1'``          tri_down marker\n      ``'2'``          tri_up marker\n      ``'3'``          tri_left marker\n      ``'4'``          tri_right marker\n      ``'s'``          square marker\n      ``'p'``          pentagon marker\n      ``'*'``          star marker\n      ``'h'``          hexagon1 marker\n      ``'H'``          hexagon2 marker\n      ``'+'``          plus marker\n      ``'x'``          x marker\n      ``'D'``          diamond marker\n      ``'d'``          thin_diamond marker\n      ``'|'``          vline marker\n      ``'_'``          hline marker\n      =============    ===============================\n  ```\n\n  \n\n  ```python\n  #line的可选值\n  =============    ===============================\n  character        description\n  =============    ===============================\n  ``'-'``          solid line style 实线\n  ``'--'``         dashed line style 虚线\n  ``'-.'``         dash-dot line style 点画线\n  ``':'``          dotted line style 点线\n  =============    ===============================\n  ```\n\n  ==如果不选maker，那么只是直接连线==\n\n  * **其他关键字**\n\n    ```python\n    lw(linewidth):线的宽度（粗细）\n    c(color):线的颜色\n    ls(linestyle):线的样式\n    marker:折点的形状\n    markeredgecolor 或 mec -- 折点外边颜色\n    markeredgewidth 或 mew -- 折点线宽\n    markerfacecolor 或 mfc --折点实心颜色\n    markerfacecoloralt 或 mfcalt\n    markersize 或 ms --折点大小\n    ```\n\n    \n\n#### errorbar方法\n\nerrorabar方法专门用来作误差线，但它无法很好的定义连线的参数，因此可以与plot方法配合使用。\n\n```python\nerrorbar(x, y,**kwargs)\n#x,y 绘图的点\n#关键字：\n#xerr,yerr: 数据的误差范围\n#fmt: 数据点的标记样式以及相互之间连接线样式\n#ecolor: 误差棒的线条颜色\n#elinewidth: 误差棒的线条粗细\n#capsize: 误差棒边界横杠的大小\n#capthick: 误差棒边界横杠的厚度\n#ms(markersize): 数据点的大小\n#mfc: 数据点的颜色\n#mec: 数据点边缘的颜色\n```\n\n## 3.文字注释\n#### text方法\n\n​\t\t==text方法专门用来向图表中添加文字==\n\n```python\npyplot.text(-3, 40, \"要添加的内容\"（可以使用Latex语法），**keyword)\n# 可选的关键字：\n# alpha 设置字体的透明度\n# family 设置字体\n# size 设置字体的大小\n# style 设置字体的风格\n# wight 字体的粗细\n# bbox 给字体添加框，alpha 设置框体的透明度， facecolor 设置框体的颜色\n```\n\n#### figtext方法\n\n \t\tfigtext方法可以向图标中任意位置添加文字\n\n```python\n#使用figtext()\nx = np.arange(0, 2*np.pi, 0.01)\nplt.plot(np.sin(x))\nplt.figtext(0.5, 0.5, \"sin(0)=0\")  # 使用figtext时，x,y代表相对值，表示图片的宽高\nplt.show()\n```\n\n\n\n#### annotate方法\n\n​\t\tannoatate方法可以添加箭头\n\n```python\nplt.figure(figsize=(6, 6))\nx = np.random.randint(0, 10, size=10)\nx[5] = 30    # 对x中索引值为5的重新赋值\nplt.plot(x)\nplt.ylim([-2, 35])\n# plt.annotate(text=\"this point is important\", xy=(5, 30), xytext=(6, 31),arrowprops={\"width\": 2, \"headlength\": 5, \"headwidth\": 5, \"shrink\": 0.1})\nplt.annotate(s=\"this point is important\", xy=(5, 30), xytext=(6, 31),arrowprops={\"arrowstyle\":\"->\"}) \n# 如果arrowprops中有arrowstyle,就不应该有其他的属性，\n#xy代表的是箭头的位置，xytext代表的是箭头文本的位置。\nplt.show()\n#箭头参数：\n#text : \"string\"\n\t\n#xy: 箭头的坐标\n\t\n#xytext: 文字的坐标\n\t\n#arrowprops: 箭头的属性，字典类型：\n#下面是箭头的属性：\n#headlength:箭头头部的长度\n\n#headwidth:箭头头部的宽度\n\t\n#facecolor：箭头颜色\n\t\n#shrink:箭头的长度（两坐标距离的比例，0~1）\n\t\n#width:箭头的宽度\n```\n\n==箭头的样式：==\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190930094144180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hIRzIwMTcxMjI2,size_16,color_FFFFFF,t_70)\n### 其他例子\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n# x轴坐标\nx = [0, 1, 2, 5, 8, 10, 15]\n# 曲线1的y轴坐标\ny1 = [188, 135, 108, 80, 74, 70, 74]\n# 右侧曲线y轴的缩放系数\nk = 7 / 200\n# 右侧曲线的y轴值\ny2 = [178 * k, 125 * k, 96 * k, 65 * k, 48 * k, 38 * k, 43 * k]\ny3 = [18, 15, 13, 9, 7, 5, 6]\ny4 = [0, 55, 76, 110, 126, 140, 132]\n# 生成子图和图像\nfig, ax1 = plt.subplots()\n# 绘制误差线，并用字典加以修饰\n# $x^2$这是使用Latex渲染\nax1.errorbar(x, y1, yerr=7, lw=1, ecolor='k', color='k', marker='o', mfc='w', ms=10,\n             capsize=3, mec='k', label=\"$SS$\")\nax1.errorbar(x, y3, yerr=7, lw=1, ecolor='k', color='k', marker='s', mfc='w', ms=7,\n             capsize=3, mec='k', label=\"$Water$\")\nax1.errorbar(x, y4, yerr=7, lw=1, ecolor='k', color='k', marker='^', mfc='w', ms=10,\n             capsize=3, mec='k', label=\"$Precipitate$\")\nax1.set_ylabel(\"PFOA amount (g)\", fontdict={'weight': 'bold', 'size': 13})\n# 开启次坐标轴\nplt.minorticks_on()\n# plt.legend(frameon=False, bbox_to_anchor=(0.915, 1)\n# 获取子图1的图例句柄和标签值\nhandles_1, labels_1 = ax1.get_legend_handles_labels()\n# 设置次坐标轴的相关参数\nplt.gca().get_xaxis().set_minor_locator(MultipleLocator(1))\nplt.gca().get_yaxis().set_major_locator(MultipleLocator(40))\nplt.gca().get_yaxis().set_minor_locator(MultipleLocator(20))\n# 设置 x轴和y轴刻度的相关参数\nplt.tick_params(which='minor', axis='x', direction='in')\nplt.tick_params(which='minor', axis='y', direction='in')\nplt.tick_params(which='major', axis='x', length=4)\nplt.tick_params(which='major', axis='y', length=4)\n# plt.annotate(xy=(0, 0), xytext=(14, 160), text=\"$y=x^2$\",\n#              arrowprops={\"width\": 2, \"headlength\": 5, \"headwidth\": 5,\n#\n#                          \"shrink\": 0.05})\n# 生成右侧的纵坐标，当前画图将以右侧为准\nax2 = plt.twinx()\n# 设置 右侧y轴的坐标轴范围\nplt.ylim(ymax=7)\nline4 = plt.errorbar(x, y2, lw=1, yerr=7 * k, marker='o', mfc='b', ms=10, capsize=3, label=\"$Residual turbidity$\")\n\nplt.gca().get_yaxis().set_minor_locator(MultipleLocator(0.5))\n# 设置右侧纵坐标的y轴参数\nplt.tick_params(which='minor', axis='y', direction='in')\nplt.tick_params(which='major', axis='y', length=4)\nax2.set_ylabel(\"Residual turbidity (NTU)\", fontdict={'weight': 'bold', 'color': 'blue', 'size': 13})\nax2.spines['right'].set_color('blue')\n# plt.legend(frameon=False, bbox_to_anchor=(1, 0.85))\n# 获得子图的图例句柄和标签值\nhandles_2, labels_2 = ax2.get_legend_handles_labels()\n# 将两个图例合并\nplt.legend(handles=handles_1 + handles_2, bbox_to_anchor=(0.1, 1))\n# 绘制标题栏\nplt.title(\"PACl dose (mg/L)\", fontdict={'weight': 'bold', 'size': 15})\n\nplt.show()\nfig.savefig('p2.svg', bbox_inches='tight')\n\n```\n\n\n\n```python\nimport kwargs as kwargs\nimport numpy as np\nfrom brokenaxes import brokenaxes\nfrom matplotlib import pyplot as plt\nfrom matplotlib.pyplot import minorticks_on\nfrom matplotlib.ticker import MultipleLocator\n\n# 此处使用numpy生成一组数列，这是x轴的值，是左闭右开的\nx = np.arange(0, 25, 5)\n# 设置y轴的值\ny1 = [0.8, 0, 0, 0, 0]\ny2 = [6.5, 2.5, 0.8, 0, 0]\ny3 = [370, 90, 8.2, 1.3, 0]\n# 生成图像和两个子图，第一个子图有两列，第二个子图有一列，ax1会在ax2下方显示\nfig, (ax2, ax1) = plt.subplots(2, 1, sharex=True)\n# 为整个图像添加一个大的子图，只是为了能够添加y轴的标题\nfig.add_subplot(211, frameon=False)\n# 隐藏ax1上方的坐标轴\nax1.spines['top'].set_visible(False)\n# 隐藏 ax2的底部坐标轴\nax2.spines['bottom'].set_visible(False)\n# 将次坐标轴打开\nminorticks_on()\n# 设置x轴和y轴的主次坐标轴间隔\nax1.xaxis.set_major_locator(MultipleLocator(5))\nax1.xaxis.set_minor_locator(MultipleLocator(2.5))\nax1.yaxis.set_minor_locator(MultipleLocator(2))\n# 设置ax1和ax2的y轴范围\nax1.set_ylim(0, 8.5)\nax2.set_ylim(95, 400)\n# 隐藏ax2的x轴刻度线\nax2.tick_params(which='both', axis='x', length=0)\n# 绘制误差线\nax1.errorbar(x, y1, yerr=0.4, fmt='k-s', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\n             label='0.5 mg/L PFOA')\nax2.errorbar(x, y1, yerr=0.4, fmt='k-s', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\n             label='0.5 mg/L PFOA')\nax1.errorbar(x, y2, yerr=0.4, fmt='k-o', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\n             label='1 mg/L PFOA')\nax2.errorbar(x, y2, yerr=0.4, fmt='k-o', lw=0.8, mfc='w', mec='k', capsize=2, elinewidth=0.2, ms=7,\n             label='1 mg/L PFOA')\nax1.errorbar(x, y3, yerr=0.4, fmt='b-^', lw=0.8, mfc='w', ecolor='blue', mec='b', capsize=2, elinewidth=0.2, ms=7,\n             label='3mg/L PFOA')\nax2.errorbar(x, y3, yerr=0.4, fmt='b-^', lw=0.8, mfc='w', ecolor='blue', mec='b', capsize=2, elinewidth=0.2, ms=7,\n             label='3mg/L PFOA')\n# 绘制两条斜杠，表示坐标轴之间不连续\nd = 0.015\n# 下面这句话是一个字典，表示以整个坐标轴的长度为单位1，颜色设为黑色\nkwargs = dict(transform=ax2.transAxes, color='k', clip_on=False, lw=0.8)\nax2.plot((-d, +d), (-d, +d), **kwargs)  # top-left diagonal\n\nkwargs.update(transform=ax1.transAxes)  # switch to the bottom axes\nax1.plot((-d, +d), (1 - d, 1 + d), **kwargs)  # bottom-left diagonal\n\nax1.plot((1, 1), (1, 1 + 20 * d), **kwargs)\n\n# What's cool about this is that now if we vary the distance between\n# ax and ax2 via f.subplots_adjust(hspace=...) or plt.subplot_tool(),\n# the diagonal lines will move accordingly, and stay right at the tips\n# of the spines they are 'breaking'\nax2.legend()\n# 将大子图的x轴 y轴 ,刻度线全部隐藏\nplt.tick_params(labelcolor='none', top='off', bottom='off', left='off', right='off')\nplt.tick_params(which='both', length=0)\n\nplt.title(\"PAC dose (mg/L)\", size='14', weight='bold')\nfig.text(0.04, 0.5, 'PFOA in water (g/L)', size='15', weight='bold', ha='center', va='center', rotation='vertical')\n\nplt.show()\nplt.title(\"PAC dose (mg/L)\")\n# 下面表示dpi表示像素密度，当时保存为矢量图就不存在像素的概念了\nfig.savefig('p3.svg', dpi=600)\n\n```\n"}]}}}]);
//# sourceMappingURL=chunk-7a8beb34.378d7e28.js.map